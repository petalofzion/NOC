# NOC Project: Comprehensive Mathematical Index

**Status:** Generated by Agent Swarm on 2025-11-27.
**Scope:** Listing of all Files, Definitions, Theorems, Lemmas, and Structures in `NOC/`.

---

## Module A: Capacity Drift & Arithmetic (NOC/A)

### `NOC/A/BasicHelp.lean`
**Summary:** Provides basic definitions and properties related to expected values and measures in the context of probability.
*   `Measure.comp_le_linfty_norm`
*   `comp_le_linfty_norm`
*   `linfty_norm_comp_le`
*   `integral_comp_le_mul_linfty_norm`
*   `integral_comp_le_linfty_norm_mul`
*   `integral_mono_comp_of_ge_one`
*   `MeasureTheory.integral_const_mul`
*   `MeasureTheory.integral_mul_const`
*   `MeasureTheory.integral_sub`
*   `integral_nonneg`
*   `integral_le_integral`
*   `integral_nonpos`
*   `integral_neg`
*   `MeasureTheory.integral_add`
*   `integral_div`
*   `integral_mul_integral`
*   `integral_mul_integral_swap`
*   `integral_comp_linfty_norm`
*   `integral_comp_linfty_norm_le`
*   `integral_comp_linfty_norm_le_of_le`
*   `integral_comp_linfty_norm_le_of_le'`
*   `integral_eq_zero_of_ae_eq_zero`
*   `integral_eq_zero_iff_ae_eq_zero_of_nonneg`
*   `integral_pos_iff_ae_pos_of_nonneg`
*   `integral_comp_pos_iff_ae_pos_of_nonneg`
*   `integral_comp_pos_iff_ae_pos_of_nonneg'`
*   `integral_mono`
*   `integral_mono_of_nonneg`
*   `integral_nonneg_of_nonneg`
*   `integral_le_integral_of_le`
*   (and ~20 variants of `integral_le_integral_of_le` for specific arity)

### `NOC/A/BasicNoHelp.lean`
*   (Content merged or empty in analysis pass - verify if critical)

### `NOC/A/Helpers.lean`
*   (General utility lemmas for arithmetic)

---

## Module B: Expected Acceleration (NOC/B)

### `NOC/B/Core.lean`
*   (Core definitions for Lemma B - Analysis pending detailed sweep)

### `NOC/B/Expectation.lean`
*   (Expectation lifting for Lemma B)

---

## Module C: The Sigma Laws (NOC/C)

### `NOC/C/C.lean`
**Summary:** Defines the acceleration form of the Σ-law ($\Delta \Sigma \ge \Delta^2 U$) and proves finitary expectation bounds.
*   `structure SigmaAccelParams`
*   `theorem lemmaC_pointwise`
*   `theorem lemmaC_expectation_finitary`
*   `theorem lemmaC_expectation_with_fraction`
*   `theorem lemmaC_pointwise_from_D`
*   `theorem lemmaC_expectation_from_D`
*   `theorem lemmaC_expectation_with_fraction_from_D`
*   `theorem lemmaC_expectation_allGood`

### `NOC/C/CPrime.lean`
**Summary:** Proves the improvement form of the Σ-law ($\Delta \Sigma \ge \Delta U$) over a finite set via "good set" splitting.
*   `structure SigmaLawParams`
*   `theorem lemmaCprime_pointwise`
*   `theorem lemmaCprime_expectation_finitary`
*   `theorem lemmaCprime_expectation_with_fraction`
*   `theorem lemmaCprime_expectation_allGood`

### `NOC/C/CPrimeToy.lean`
**Summary:** A toy 2×2 tabular instance for the Σ-law (C′) with explicit constants.
*   `structure TwoByTwo`
*   `structure TwoByTwoData`
*   `theorem toy_Cprime_exists`
*   `theorem toy_Cprime_finitary_demo`

---

## Module D: Stability & TTSA (NOC/D)

### `NOC/D/BetaStability.lean`
**Summary:** Scaffolding for Lemma D (β-stability), recording hypotheses like TTSA schedules.
*   `structure MetaRegularizerData`
*   `structure TTSAHypotheses`
*   `structure AccelerationWindow`
*   `structure BetaStabilityContext`
*   `lemma lemmaD_beta_stability`

### `NOC/D/BetaStabilityTTSA.lean`
**Summary:** Concrete Two-Time-Scale Stochastic Approximation (TTSA) framework.
*   `structure TTSASchedules`
*   `structure TTSANoise`
*   `structure MetaReg`
*   `structure AccelWindow`
*   `structure BetaTTSAContext`
*   `lemma BetaTTSAContext.proj_eval`
*   `def betaUpdate`
*   `lemma beta_drift_lower_on_window`
*   `theorem lemmaD_beta_stability_TTSA`
*   `structure DriftHitThresholdContext`
*   `def DriftHitThresholdContext.betaSeq`
*   `lemma DriftHitThresholdContext.proj_eval`
*   `structure TTSA.ProjIccProps`
*   `structure TTSA.BetaUpdate`
*   `def TTSA.BetaUpdate.update`
*   `lemma TTSA.BetaUpdate.update_eval`
*   `def TTSA.iter`
*   `def TTSA.clamp`
*   `lemma TTSA.clamp_props`
*   `lemma TTSA.props_of_is_clamp`
*   `def TTSA.BetaUpdate.clamped`
*   `lemma TTSA.BetaUpdate.clamped_props`
*   `lemma TTSA.update_bounds`
*   `lemma TTSA.iter_bounds`
*   `lemma TTSA.update_monotone_on_window`
*   `theorem TTSA.beta_drift_lower_bound_props`
*   `theorem TTSA.beta_hits_target_props`
*   `theorem TTSA.beta_drift_lower_bound`
*   `theorem TTSA.beta_hits_target`
*   `structure DriftHitThresholdPropsContext`
*   `def DriftHitThresholdPropsContext.betaSeq`
*   `theorem DriftHitThresholdPropsContext.hits_threshold_props`
*   `theorem TTSA.clamped_monotone_on_window`
*   `theorem TTSA.clamped_hitting_time_under_window`
*   `theorem DriftHitThresholdContext.hits_threshold`
*   `theorem lemmaD_beta_stability_TTSA_window`
*   `structure TTSATrackingHypotheses`
*   `theorem lemmaD_beta_stability_TTSA_ode`

### `NOC/D/Interfaces.lean`
**Summary:** Glue to use the D-bridge, declaring link predicates.
*   `def UpperLinkOn`
*   `def SDPILinkOn`
*   `def UpperLink`
*   `def SDPILink`
*   `lemma toSigmaLawParams_c1`
*   `lemma toSigmaLawParams_lambdaXi`
*   `lemma pointwise_Cprime_from_D`
*   `lemma pointwise_Cprime_on_from_D`
*   `theorem expectation_from_links`
*   `theorem expectation_with_fraction_from_links`

### `NOC/D/TTSA_Convergence.lean`
**Summary:** Theorem targets for 1-D projected SA and full TTSA convergence.
*   `lemma sq_sum_le_three`
*   `lemma window_prod_lb`
*   `lemma clamp_nonexpansive`
*   `lemma clamp_in_range`
*   `lemma pospart_sub_sq_le`
*   `lemma pospart_add_le_posparts`
*   `lemma pospart_add_le_pos_abs`
*   `lemma add_sq_le_two_sq`
*   `lemma pospart_add_sq_le_two`
*   `lemma pospart_sub_mono_left`
*   `lemma barrier_ineq_unprojected`
*   `lemma pospart_K_clamp_le`
*   `lemma barrier_ineq_projected`
*   `lemma rs_step_pointwise`
*   `structure OneDProjectedSAHypotheses`
*   `def projected_SA_converges_1D`
*   `def projected_SA_converges`
*   `structure D6RSData`
*   `structure D6RSField`
*   `def D6RS_Y`
*   `def D6RS_u`
*   `def D6RS_v`
*   `def D6RS_w`
*   `def D6_RS_condExp_ineq`
*   `def D6_RS_w_summable`
*   `def D6_RS_interior_hit_goal`
*   `def D6_RS_interior_hit_from_RS`
*   `theorem D6_scalar_RS_u0_summable`
*   `structure D6ScalarRSContext`
*   `theorem d6_vsum_summable_from_scalar`
*   `def D6_S`
*   `def D6_v`
*   `lemma D6_S_nonneg`
*   `lemma D6_v_nonneg`
*   `structure D6ProbAssumptions`
*   `lemma D6ProbAssumptions.beta_range`
*   `def d6_phi`
*   `def d6_chi`
*   `def d6_psi`
*   `lemma abs_le_sq_add_one`
*   `lemma integrable_abs_of_sq`
*   `lemma integral_phi_mul_condexp_zero`
*   `lemma integral_window_lb`
*   `lemma d6_phi_nonneg`
*   `lemma d6_phi_le_K`
*   `lemma d6_phi_aestronglyMeasurable`
*   `lemma d6_phi_integrable`
*   `lemma d6_chi_aestronglyMeasurable`
*   `lemma d6_g_sq_integrable`
*   `lemma d6_g_abs_integrable`
*   `lemma d6_phi_mul_g_integrable`
*   `lemma d6_phi_sq_integrable`
*   `lemma d6_chi_sq_integrable`
*   `lemma d6_psi_aestronglyMeasurable`
*   `lemma d6_psi_sq_integrable`
*   `lemma d6_phi_mul_psi_integrable`
*   `lemma d6_xi_abs_integrable`
*   `lemma d6_phi_mul_xi_integrable`
*   `lemma d6_delta_abs_integrable`
*   `lemma d6_phi_mul_delta_integrable`
*   `lemma d6_phi_delta_smul_bound`
*   `lemma d6_phi_mul_chi_integrable`
*   `lemma d6_chi_sq_integral_bound`
*   `lemma d6_window_lower_bound`
*   `theorem d6_scalar_RS_summable`
*   `lemma ae_summable_of_summable_integral_nonneg`
*   `lemma d6_weighted_gap_ae_summable`
*   `lemma not_eventually_ge_of_weighted_summable`
*   `structure OneDInteriorHitHypotheses`
*   `def projected_SA_interior_hit`
*   `theorem ttsa_interior_hit_via_RS`
*   `theorem projected_SA_converges_1D_full`
*   `structure D4RSData`
*   `def D4RS_Y`
*   `def D4_RS_condExp_ineq`
*   `def D4_RS_w_summable`
*   `def D4_RS_converges_goal`
*   `def D4_RS_converges_from_RS`
*   `structure PathwiseSASeq`
*   `theorem pathwise_interior_hit`
*   `structure TTSAUniqueEqHypotheses`
*   `def TTSA_projected_unique_equilibrium`
*   `structure TTSAErgodicHypotheses`
*   `def TTSA_projected_ergodic`

---

## Module E: Information & Empowerment (NOC/E)

### `NOC/E/Core.lean`
**Summary:** Infrastructure for Lemma E (synergistic empowerment) including POMDPs and policy profiles.
*   `structure FinPOMDP`
*   `structure PolicyProfile`
*   `structure ESynergyWitness`
*   `structure SDPIHypothesis`
*   `structure SynergisticEmpowermentContext`
*   `lemma lemmaE_synergistic_empowerment`

### `NOC/E/ConditionalDIDPI.lean`
**Summary:** Formal shell for conditional Directed-Information DPI.
*   `structure FiniteProcess`
*   `structure Garbling`
*   `structure DirectedInformation`
*   `structure DIDPIContext`
*   `theorem di_dpi_from_perstep`
*   `theorem di_dpi_from_perstep_strict`
*   `structure MasseyChainDecomp`
*   `def perStepSDPI`
*   `def perStepSDPI_strict`
*   `theorem conditional_DI_DPI_massey`
*   `theorem conditional_DI_DPI_massey_strict`
*   `theorem conditional_DI_DPI_def`
*   `theorem conditional_DI_DPI_def_strict`
*   `theorem conditional_DI_DPI`

### `NOC/E/ConversionVsAblation.lean`
**Summary:** Algebraic inequality for "Conversion > Ablation" (ROI).
*   `structure ROIParams`
*   `structure ROIContext`
*   `theorem roi_from_sigma_law`
*   `theorem roi_sufficient_conditions`
*   `theorem conversion_beats_ablation`

### `NOC/E/Interfaces/DI.lean`
**Summary:** Standard typeclasses for Directed Information and SDPI.
*   `abbrev Time`
*   `class DirectedInfo`
*   `class SDPI`
*   `class SDPIStepWitness`
*   `theorem DI.massey_chain_rule`
*   `theorem DI.sdpi_step_inequality`
*   `theorem DI.di_monotone_under_garbling`
*   `theorem DI.di_strict_under_garbling`
*   `theorem DI.di_monotone_under_garbling_explicit`
*   `theorem DI.di_strict_under_garbling_explicit`

### `NOC/E/Interfaces/DI_NOC_Instance.lean`
**Summary:** Scaffolding for concrete per-step models in DI.
*   `structure DI.NOCStepModel`
*   `def DI.mkPerStepData`
*   `def DI.mkSDPIData`
*   `def DI.mkSDPIStepData`

### `NOC/E/Boundary/GaussianMAC.lean`
**Summary:** Gaussian MAC counterexample for ablation vs interference.
*   `structure GaussianMAC`
*   `def mi_of_snr`
*   `def snr_with_interference`
*   `def snr_after_ablation`
*   `lemma mi_of_snr_strict_mono`
*   `theorem mi_after_ablation_strict`
*   `theorem mi_after_ablation_ge_with_interference`
*   `theorem mi_increase_after_ablation`
*   `theorem interference_counterexample`
*   `theorem scalar_instance_ge`
*   `theorem scalar_instance_strict`

---

## Module HB: Heavy Ball Dynamics (NOC/HB)

### `NOC/HB/AdaptiveIntegration.lean`
**Summary:** Proves Heavy Ball acceleration is positive with adaptive step size.
*   `structure AdaptiveParams`
*   `structure AdaptiveScenario`
*   `def AdaptiveScenarios`
*   `def cap_a`
*   `def cap_b`
*   `lemma cap_b_pos`
*   `def adaptive_gap_coeff`
*   `theorem adaptive_pointwise_acceleration`
*   `def adaptive_d2U_func`
*   `def adaptive_energy_func`
*   `theorem adaptive_average_positive`

### `NOC/HB/CloseLoop.lean`
**Summary:** Heavy-ball closed-loop algebra and one-variable reduction.
*   `def tau`
*   `lemma d_eq_e_sub_ep`
*   `lemma delta2_f_hb_in_e_d`
*   `lemma delta2_f_upper_bound_via_rho`
*   `def hb_rhoStar`
*   `lemma hb_rhoStar_nonneg`
*   `lemma hb_bracket_nonpos`
*   `lemma hb_delta2f_nonpos_of_small_rel_step`
*   `theorem lemmaB_HB_affine_capacity`
*   `lemma delta2_f_nonpos_under_rho`
*   `lemma delta2_f_gap_under_rho`

### `NOC/HB/Integration.lean`
**Summary:** Finite ensemble of 1D quadratic tasks and expected acceleration.
*   `def agent_params`
*   `structure Scenario`
*   `def Scenarios`
*   `def cap_a`
*   `def cap_b`
*   `lemma cap_b_pos`
*   `def gap_coeff`
*   `lemma rho_star_tight_bound`
*   `theorem pointwise_acceleration_gap`
*   `def d2U_func`
*   `def energy_func`
*   `theorem average_acceleration_positive`

### `NOC/HB/Link.lean`
**Summary:** Linking Heavy Ball models to Sigma-Law inputs.
*   `structure HBLinkBundle`
*   `lemma HBLinkBundle.pointwise_Cprime`
*   `structure HBLinkBundleOn`
*   `lemma HBLinkBundleOn.pointwise_Cprime_on`
*   `theorem HBLinkBundleOn.expectation_finitary`
*   `theorem HBLinkBundleOn.expectation_with_fraction`

### `NOC/HB/Quadratic.lean`
**Summary:** Heavy-ball parameters and discrete difference operators on 1D quadratics.
*   `structure HBParams`
*   `def hbStep`
*   `def delta2`
*   `def f_at`
*   `lemma hb_error_next_eq`
*   `lemma delta2_f_at_eq`
*   `lemma delta2_f_hb_closed_form`
*   `lemma quad_f_step_abs_le_general`
*   `lemma quad_f_step_abs_le`
*   `lemma quad_f_stepSquares_le`

---

## Module Prob: Probability & Martingales (NOC/Prob)

### `NOC/Prob/Alignment.lean`
**Summary:** Minimal record for drift alignment.
*   `structure AlignsWithGbar`

### `NOC/Prob/MDS.lean`
**Summary:** Martingale Difference Sequences (MDS) scaffolding.
*   `structure MDSData`
*   `lemma MDSData.half_nonneg`
*   `lemma MDSData.eLpNorm_two_eq_rpow`
*   `def MDSData.partialSum`
*   `lemma MDSData.partialSum_zero`
*   `lemma MDSData.partialSum_succ`
*   `lemma MDSData.partialSum_adapted`
*   `lemma MDSData.partialSum_integrable`
*   `lemma MDSData.partialSum_diff`
*   `lemma MDSData.scaled_condExp_zero`
*   `lemma MDSData.partialSum_condExp_diff_zero`
*   `lemma MDSData.partialSum_martingale`
*   `def MDSData.varianceTerm`
*   `lemma MDSData.varianceTerm_succ`
*   `lemma MDSData.seq_sq_integrable`
*   `lemma MDSData.diff_sq_integrable`
*   `lemma MDSData.partialSum_diff_sq_integral`
*   `lemma MDSData.add_sq_le_two_sq`
*   `lemma MDSData.partialSum_sq_integrable_aux`
*   `lemma MDSData.partialSum_sq_integrable`
*   `lemma MDSData.abs_mul_le_half_sq_add_sq`
*   `lemma MDSData.partialSum_mul_diff_integrable`
*   `lemma MDSData.partialSum_cross_integral_zero`
*   `lemma MDSData.partialSum_sq_integral_eq_varianceTerm`
*   `structure MDSWeightedSumHypotheses`
*   `structure MDSWeightedSumConclusion`
*   `def mds_weighted_sum_converges`
*   `theorem MDSData.weighted_sum_ae_converges`

### `NOC/Prob/RobbinsSiegmund.lean`
**Summary:** Robbins-Siegmund convergence theorem.
*   `structure RSHypotheses`
*   `structure RSConclusion`
*   `def robbins_siegmund`
*   `theorem supermartingale_exists_ae_tendsto_of_bdd`
*   `structure RSNormalization`
*   `theorem RSNormalization.ae_converges`
*   `def RSWeight`
*   `lemma RSWeight_zero`
*   `lemma RSWeight_succ`
*   `lemma RSWeight_pos_of_nonneg`
*   `lemma RS_expectation_step`
*   `lemma RS_vsum_partial_bound`
*   `lemma RS_vsum_summable_of_w_summable`
*   `lemma RS_vsum_summable_of_w_summable_u_zero`
*   `lemma RS_vsum_summable_of_w_summable_scalar`
*   `def RSZ`
*   `def RSVsum`
*   `def RSWsum`
*   `def RSDrifted`
*   `lemma RSDrifted_l1_uniform_bound_of_w_summable`
*   `lemma RSDrifted_supermartingale_of_RS`
*   `theorem RSDrifted_ae_converges_of_RS`
*   `theorem NOC.TTSA.RS_drifted_ae_converges_core`
*   `theorem NOC.TTSA.RS_summable_u_zero_core`
*   `theorem NOC.TTSA.RS_summable_scalar_core`

---

## Misc Modules

### `NOC/Bridge/SigmaBridge.lean`
**Summary:** Defines the Sigma-bridge to eliminate intermediate variables.
*   `structure SigmaBridgeParams`
*   `def SigmaBridgeParams.toSigmaLawParams`
*   `lemma SigmaBridgeParams.sigma_from_upper`
*   `theorem lemmaBridge_expectation_finitary`
*   `theorem lemmaBridge_expectation_with_fraction`
*   `lemma SigmaBridgeParams.c1_from_bridge`
*   `lemma SigmaBridgeParams.lambdaXi_from_bridge`

### `NOC/Dev/Checks.lean`
**Summary:** Smoke tests for elaboration.
*   (No formal definitions)
